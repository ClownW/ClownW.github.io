<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">

  
  <title>图 | ClownW的博客</title>

  <link rel="shortcut icon" href="../images/favicon.png">
  <link rel="alternate" href="../atom.xml" title="ClownW的博客">
  <meta name="description" content="图1.用打表法解题     这是一道有向图题，判断[u,v]中u是否是v的前驱（本质是求有向图两点是否存在通路）。用DFS会导致超时，直接用打表法。 123456789101112131415class Solution:    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[L">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="http://clownw.github.io/%E5%9B%BE/">
<meta property="og:site_name" content="ClownW的博客">
<meta property="og:description" content="图1.用打表法解题     这是一道有向图题，判断[u,v]中u是否是v的前驱（本质是求有向图两点是否存在通路）。用DFS会导致超时，直接用打表法。 123456789101112131415class Solution:    def checkIfPrerequisite(self, n: int, prerequisites: List[List[int]], queries: List[L">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%951.png">
<meta property="og:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%952.png">
<meta property="og:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%953.png">
<meta property="og:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%954.png">
<meta property="og:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%955.png">
<meta property="og:image" content="http://clownw.github.io/images/desp802.png">
<meta property="og:image" content="http://clownw.github.io/images/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84.png">
<meta property="og:image" content="http://clownw.github.io/images/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86.png">
<meta property="og:image" content="http://clownw.github.io/images/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE1.png">
<meta property="og:image" content="http://clownw.github.io/images/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE2.png">
<meta property="article:published_time" content="2020-05-31T07:34:43.000Z">
<meta property="article:modified_time" content="2020-06-02T16:50:00.030Z">
<meta property="article:author" content="ClownW">
<meta property="article:tag" content="算法总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://clownw.github.io/images/%E6%89%93%E8%A1%A8%E6%B3%951.png">

  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content="">
  <meta name="keywords" content=",算法总结">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="ClownW的博客">
  <meta name="msapplication-starturl" content="http://clownw.github.io">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ClownW的博客">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="../images/favicon.png">

  
    <meta property="article:published_time" content="Sun May 31 2020 15:34:43 GMT+0800">
    <meta property="article:modified_time" content="Wed Jun 03 2020 00:50:00 GMT+0800">
  

  
    <link rel="canonical" href="http://clownw.github.io">
  

  
  

  
  
  

  
<link rel="stylesheet" href="../css/mdui.css">
<link rel="stylesheet" href="../css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="../index.html" class="mdui-typo-headline">ClownW的博客</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="../atom.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="Enter the key words">
    </div>
    <div class="search-result" data-resource="../search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="../images/banner.png" style="height: 160px;">
    <img src="../images/portrait.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">ClownW</div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i></div>
      </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="../index.html" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">inbox</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="../archives/2020/05/">五月 2020<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="../archives/2020/04/">四月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="../archives/2020/03/">三月 2020<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="../archives/2020/02/">二月 2020<span class="mdui-ripple sidebar_archives-count">8</span></a><a class="mdui-ripple sidebar_archives-link" href="../archives/2020/01/">一月 2020<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
        
          <a href="javascript:;" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme" style="justify-content: center;">分类为空</a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="../tags/Leetcode-Top-Interview-Questions/" rel="tag">Leetcode Top Interview Questions<span class="mdui-ripple sidebar_archives-count">7</span></a><a class="mdui-ripple sidebar_archives-link" href="../tags/learn/" rel="tag">learn<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="../tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag">神经网络<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="../tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" rel="tag">算法学习<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="../tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag">算法总结<span class="mdui-ripple sidebar_archives-count">7</span></a>
        
      </div>
    </div>
    <a href="../about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
          <a href="https://github.com/ClownW" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">My github profile</a>
        
        
      </div>
    </div>
  </div>
</aside>
  <main id="main" class="mdui-m-t-5 fadeIn animated">
  
<link rel="stylesheet" href="../https:/cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-16.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">图</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2020-05-31 / <i class="iconfont">&#xe601;</i> ClownW</div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">Send to mobile phone</a></li>
            
            <li class="mdui-menu-item" disabled>
              
                <img src="http://qr.liantu.com/api.php?w=246&m=10&text=http://clownw.github.io/%E5%9B%BE/">
              
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="http://service.weibo.com/share/share.php?appkey=&title=图&url=http://clownw.github.io/%E5%9B%BE/&pic=http://clownw.github.io../images/favicon.png&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到微博</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://twitter.com/intent/tweet?text=图&url=http://clownw.github.io/%E5%9B%BE/&via=ClownW" target="_blank" class="mdui-ripple">分享到Twitter</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=http://clownw.github.io/%E5%9B%BE/" target="_blank" class="mdui-ripple">分享到Facebook</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://plus.google.com/share?url=http://clownw.github.io/%E5%9B%BE/" target="_blank" class="mdui-ripple">分享到Google+</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://clownw.github.io/%E5%9B%BE/&title=图" target="_blank" class="mdui-ripple">分享到LinkedIn</a>
            </li>
            <li class="mdui-menu-item">
              <a href="http://connect.qq.com/widget/shareqq/index.html?site=ClownW的博客&title=图&summary=&pics=http://clownw.github.io../images/favicon.png&url=http://clownw.github.io/%E5%9B%BE/" target="_blank" class="mdui-ripple">分享到QQ</a>
            </li>
            <li class="mdui-menu-item">
              <a href="https://telegram.me/share/url?url=http://clownw.github.io/%E5%9B%BE/&text=图" target="_blank" class="mdui-ripple">分享到Telegram</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h3 id="1-用打表法解题"><a href="#1-用打表法解题" class="headerlink" title="1.用打表法解题"></a>1.用打表法解题</h3><p><img src="../images/%E6%89%93%E8%A1%A8%E6%B3%951.png" alt=""></p>
<p><img src="../images/%E6%89%93%E8%A1%A8%E6%B3%952.png" alt=""></p>
<p><img src="../images/%E6%89%93%E8%A1%A8%E6%B3%953.png" alt=""></p>
<p><img src="../images/%E6%89%93%E8%A1%A8%E6%B3%954.png" alt=""></p>
<p><img src="../images/%E6%89%93%E8%A1%A8%E6%B3%955.png" alt=""></p>
<p>这是一道有向图题，判断[u,v]中u是否是v的前驱（本质是求有向图两点是否存在通路）。用DFS会导致超时，直接用打表法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]       </span><br><span class="line">        <span class="keyword">for</span> p, c <span class="keyword">in</span> prerequisites:</span><br><span class="line">            dp[p][c] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment"># 对每个点i</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n): <span class="comment"># 找到i的前驱</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n): <span class="comment"># 找到i的后继</span></span><br><span class="line">                    <span class="keyword">if</span> dp[j][i] <span class="keyword">and</span> dp[i][k]:</span><br><span class="line">                        dp[j][k] = <span class="literal">True</span> <span class="comment"># i的前驱也是i的后继的前驱</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> queries:</span><br><span class="line">            ans.append(dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="2-拓扑排序法"><a href="#2-拓扑排序法" class="headerlink" title="2.拓扑排序法"></a>2.拓扑排序法</h3><p><img src="../images/desp802.png" alt=""></p>
<p>本质是求有向图中，一个点是否在环中或能否走进环中。</p>
<p>拓扑排序思路：</p>
<p>​        对于一个节点 u，如果我们从 u 开始任意行走能够走到一个环里，那么 u 就不是一个安全的节点。换句话说，u 是一个安全的节点，当且仅当 u 直接相连的节点（u 的出边相连的那些节点）都是安全的节点。</p>
<p>​        因此我们可以首先考虑没有任何出边的节点，它们一定都是安全的。随后我们再考虑仅与这些节点直接相连的节点，它们也一定是安全的，以此类推。这样我们可以将所有的边全部反向，首先所有没有任何入边的节点都是安全的，我们把这些节点全部移除。随后新的图中没有任何入边的节点都是安全的，以此类推。我们发现这种做法实际上就是对图进行拓扑排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        rgraph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i,item <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> item:</span><br><span class="line">                q.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> item:</span><br><span class="line">                rgraph[j].append(i)</span><br><span class="line">        graph = list(map(set, graph))</span><br><span class="line">        safe = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(graph))]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            j = q.popleft()</span><br><span class="line">            safe[j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> rgraph[j]:</span><br><span class="line">                graph[i].remove(j)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> graph[i]:</span><br><span class="line">                    q.append(i)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(safe) <span class="keyword">if</span> v]</span><br></pre></td></tr></table></figure>

<h3 id="3-深度优先搜索"><a href="#3-深度优先搜索" class="headerlink" title="3.深度优先搜索"></a>3.深度优先搜索</h3><p>同样是上一题，还可以用深度优先搜索的方法。（使用颜色来标记状态，使用一个一维数组color来表示颜色）</p>
<p>​        我们同样可以使用深度优先搜索的方法判断图中的每个节点是否能走到环中。对于每个节点，我们有三种染色的方法：白色表示该节点还没有被访问过；灰色表示该节点在栈中（这一轮搜索中被访问过）或者在环中；黑色表示该节点的所有相连的节点都被访问过，且该节点不在环中。</p>
<p>​        当我们第一次访问一个节点时，我们把它从白色变成灰色，并继续搜索与它相连的节点。如果在搜索过程中我们遇到一个灰色的节点，那么说明找到了一个环，此时退出搜索，所有的灰色节点保持不变（即从任意一个灰色节点开始，都能走到环中），如果搜索过程中，我们没有遇到灰色的节点，那么在回溯到当前节点时，我们把它从灰色变成黑色，即表示它是一个安全的节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        WHITE, GRAY, BLACK = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        color = collections.defaultdict(int)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> color[node] != white:</span><br><span class="line">                <span class="keyword">return</span> color[node] == BLACK</span><br><span class="line"></span><br><span class="line">            color[node] = GRAY</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> color[nei] == BLACK:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> color[nei] == GRAY <span class="keyword">or</span> <span class="keyword">not</span> dfs(nei):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            color[node] = BLACK</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> filter(dfs, range(len(graph)))</span><br></pre></td></tr></table></figure>

<p><strong>可以证明：</strong>如果一个点是安全的，则在访问其他点时，这个点的颜色不可能为灰色（可能为白色，黑色）。因为刚访问到这个点时将这个点置为灰色，但马上dfs访问他的邻居，其邻居必然也是安全的，依次类推，直到dfs访问到没有出度的节点（终点），此时将路径上所有的点的颜色改为黑色。</p>
<h3 id="4-Hierholzer-算法"><a href="#4-Hierholzer-算法" class="headerlink" title="4.Hierholzer 算法"></a>4.Hierholzer 算法</h3><p>​        Hierholzer 算法用来求<strong>欧拉路径</strong>。当保证图是欧拉图（存在欧拉回路，不存在奇度定点的连通图）或者半欧拉图（存在欧拉路径，有两个奇度定点的连通图，此时一个为起点一个为终点）时，可以无脑利用dfs求欧拉路径。</p>
<p><img src="../images/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84.png" alt=""></p>
<p><strong>Hierholzer 算法思想：</strong>当给定的图一定有欧拉路径（回路）时，从一个合理的起始点出发，深度优先遍历整个图，遍历过的边都不得再遍历，直到遇到的第一个没有可遍历的邻居的顶点，这个顶点一定是某条欧拉路径的终点，把这个顶点“删掉”（实际上不用删，通过标记边已访问就可以不再访问它）后，下一次遇到的没有可遍历的邻居的顶点，一定是这条欧拉路径倒数第二个顶点，再把这个顶点“删掉”再遍历，以此类推，直到把所有没有可遍历的邻居的顶点找到，我们就找到了这条欧拉路径上的所有顶点。</p>
<p><strong>Hierholzer 算法过程</strong>：</p>
<ul>
<li>选择一个合理的点作为起始点，遍历所有相邻边。</li>
<li>深度优先搜索，访问相邻顶点。将经过的边都不能再访问。</li>
<li>如果当前顶点没有相邻边，则将顶点入数组末尾。</li>
<li>最后将数组倒序输出，就是从起点出发的欧拉回路。</li>
</ul>
<p>在这道题中，除了找到欧拉路径外还有个额外的要求，要输出字典序最小的欧拉路径。只要把邻居进行排序即可。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span><span class="params">(self, tickets: List[List[str]])</span> -&gt; List[str]:</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 相同邻居保存两次</span></span><br><span class="line">        <span class="keyword">for</span> u,v <span class="keyword">in</span> tickets:</span><br><span class="line">            graph[u].append(v)</span><br><span class="line">        <span class="comment"># 逆序排序，对应后面用pop方法</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> graph.items():</span><br><span class="line">            v.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(v)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> graph[v]:</span><br><span class="line">                dfs(graph[v].pop())</span><br><span class="line">            ans.append(v)</span><br><span class="line">        dfs(<span class="string">"JFK"</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>C++代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：</span></span><br><span class="line"><span class="comment">// Hierholzer算法。个人觉得Hierholzer算法就是证明了一点：当存在欧拉路径时，从合理的起始点无脑dfs遍历，得到的路径一定是欧拉路径。</span></span><br><span class="line"><span class="comment">// 因为题目规定了一定有欧拉路径，并且起点一定是JFK（所以这个起始点一定是合理的），所以根据Hierholzer算法，可以无脑dfs。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这里用map，内部自动按照string升序排列了，所以先找到的一定是自然排序最小的路径</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; adjacent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; min_path;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(adjacent &amp;adj, <span class="built_in">string</span> airport)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 无脑dfs遍历邻居，同时遍历过的边标记已遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[next, number] : adj[airport])&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &gt;= number)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            --number;</span><br><span class="line">            dfs(adj, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终点是没有相邻边的点</span></span><br><span class="line">        <span class="comment">// 当删除终点后，终点前的点也没有相邻边了，变成新的终点</span></span><br><span class="line">        <span class="comment">// 运行到这里，当前airport一定没有可遍历的相邻边了，则它是此时的终点</span></span><br><span class="line">        min_path.push_back(airport);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化邻接表，因为存在多张相同机票的情况，所以邻接表中还记录了从from到to的机票数</span></span><br><span class="line">        adjacent adj;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; t : tickets)&#123;</span><br><span class="line">            <span class="keyword">if</span>(adj.<span class="built_in">find</span>(t[<span class="number">0</span>]) == adj.<span class="built_in">end</span>())</span><br><span class="line">                adj[t[<span class="number">0</span>]] = <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">            <span class="keyword">if</span>(adj[t[<span class="number">0</span>]].<span class="built_in">find</span>(t[<span class="number">1</span>]) == adj[t[<span class="number">0</span>]].<span class="built_in">end</span>())</span><br><span class="line">                adj[t[<span class="number">0</span>]][t[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">            adj[t[<span class="number">0</span>]][t[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Hierholzer算法</span></span><br><span class="line">        dfs(adj, <span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hierholzer算法得到结果为终点到起点的路径，需要反转才是题目所要求的结果</span></span><br><span class="line">        <span class="built_in">std</span>::reverse(min_path.<span class="built_in">begin</span>(), min_path.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> min_path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-带权值的并查集"><a href="#5-带权值的并查集" class="headerlink" title="5.带权值的并查集"></a>5.带权值的并查集</h3><p><img src="../images/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86.png" alt=""></p>
<p>​        这是一道带权值的并查集例题。</p>
<p>​        以往的并查集只管连通性，边是无权的。在这里可以把边的权重设为节点/父节点的值。</p>
<p>对queries中的每个方程组，查询a，b是否连通，若不连通，返回-1；若连通，返回二者的商。</p>
<p>​        这里求a/b，由于a，b连通，也意味着有共同的root，也就是可以用(a/root)/(b/root)来求出a/b的值，因此可以考虑在find的时候返回a/root（因为find要从a遍历到root，把路径的上的边权相乘就得到了a/root）。</p>
<p>​        同样在union时，知道了a/root1, b/root2，此时要设par[root1] = root2，因此要改变weights[root1]的值，改变为root1/root2，可以通过(root1/a)*(a/b)*(b/root2)来获得。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.par = &#123;&#125;</span><br><span class="line">        self.weights = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 当queries中出现没出现过的变量时，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.par:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">""</span>, <span class="number">-1.0</span>]</span><br><span class="line">        w = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">while</span> x != self.par[x]:</span><br><span class="line">            <span class="comment"># 求x/root</span></span><br><span class="line">            w *= self.weights[x]</span><br><span class="line">            x = self.par[x]</span><br><span class="line">        <span class="keyword">return</span> [x, w]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y, x_y)</span>:</span></span><br><span class="line">        root_x, w_x = self.find(x)</span><br><span class="line">        root_y, w_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> root_x==<span class="string">""</span> <span class="keyword">or</span> root_y==<span class="string">""</span> <span class="keyword">or</span> root_x == root_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.par[root_x] = root_y</span><br><span class="line">        <span class="comment"># 修改weights[root_x]为root_x/root_y</span></span><br><span class="line">        self.weights[root_x] = <span class="number">1</span>/w_x*x_y*w_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations, values, queries)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type equations: List[List[str]]</span></span><br><span class="line"><span class="string">        :type values: List[float]</span></span><br><span class="line"><span class="string">        :type queries: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        uf = UnionFind()</span><br><span class="line">        <span class="keyword">for</span> a,b <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> uf.par:</span><br><span class="line">                uf.par[a] = a</span><br><span class="line">                uf.weights[a] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> uf.par:</span><br><span class="line">                uf.par[b] = b</span><br><span class="line">                uf.weights[b] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i,(a,b) <span class="keyword">in</span> enumerate(equations):</span><br><span class="line">            uf.union(a, b, values[i])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a,b <span class="keyword">in</span> queries:</span><br><span class="line">            root_a, w_a = uf.find(a)</span><br><span class="line">            root_b, w_b = uf.find(b)</span><br><span class="line">            <span class="keyword">if</span> root_a==<span class="string">""</span> <span class="keyword">or</span> root_b==<span class="string">""</span> <span class="keyword">or</span> root_a != root_b:</span><br><span class="line">                res.append(<span class="number">-1.0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(w_a/w_b)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这道题也可以利用打表法来做，非常直接，也能AC。</p>
<h3 id="6-广度优先搜索"><a href="#6-广度优先搜索" class="headerlink" title="6.广度优先搜索"></a>6.广度优先搜索</h3><p><img src="../images/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE1.png" alt=""></p>
<p><img src="../images/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%9B%BE2.png" alt=""></p>
<p>​        这是一道求出发点到所有点红蓝交替最短路径问题，最短路可以用Dijkstra算法解决，因此首先考虑广度优先搜索。由于这道题涉及到红蓝交替路径，因此用两个表来分别存储红色邻居和蓝色邻居。由于存在重边（可能不同色），因此需要用一个visited集合来标记已经经过的边。因为是最短路，所以已经经过的边不可能再经过一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestAlternatingPaths</span><span class="params">(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        q, res = collections.deque(), [<span class="number">-1</span>]*n</span><br><span class="line">        <span class="comment"># 用来存储点的红色邻居和蓝色邻居</span></span><br><span class="line">        red_nei, blue_nei = collections.defaultdict(list), collections.defaultdict(list)</span><br><span class="line">        RED,BLUE = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="comment"># 用来存储已经标记过的边</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">for</span> u,v <span class="keyword">in</span> red_edges:</span><br><span class="line">            red_nei[u].append((v))</span><br><span class="line">            <span class="keyword">if</span> u==<span class="number">0</span>:</span><br><span class="line">                q.append((v, RED, <span class="number">1</span>))</span><br><span class="line">                visited.add((<span class="number">0</span>,v,RED))</span><br><span class="line">                res[v] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> u,v <span class="keyword">in</span> blue_edges:</span><br><span class="line">            blue_nei[u].append((v))</span><br><span class="line">            <span class="keyword">if</span> u==<span class="number">0</span>:</span><br><span class="line">                q.append((v, BLUE, <span class="number">1</span>))</span><br><span class="line">                visited.add((<span class="number">0</span>,v,BLUE))</span><br><span class="line">                res[v] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            v,color,l = q.popleft()</span><br><span class="line">            <span class="comment"># 刚经过红边，需要找蓝色邻居</span></span><br><span class="line">            <span class="keyword">if</span> color==RED <span class="keyword">and</span> v <span class="keyword">in</span> blue_nei:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> blue_nei[v]:</span><br><span class="line">                    <span class="comment"># 边没有访问过</span></span><br><span class="line">                    <span class="keyword">if</span> (v,node,BLUE) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((v,node,BLUE))</span><br><span class="line">                        q.append((node, BLUE,l+<span class="number">1</span>))</span><br><span class="line">                    <span class="comment"># 如果这点也没访问过，则找到一个新的可达点，且由于是广度优先搜索，必然是最短路</span></span><br><span class="line">                    <span class="keyword">if</span> res[node] == <span class="number">-1</span>:</span><br><span class="line">                        res[node] = l+<span class="number">1</span></span><br><span class="line">            <span class="comment"># 刚经过蓝边，需要找红色邻居</span></span><br><span class="line">            <span class="keyword">elif</span> color==BLUE <span class="keyword">and</span> v <span class="keyword">in</span> red_nei:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> red_nei[v]:</span><br><span class="line">                    <span class="keyword">if</span> (v,node,RED) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((v,node,RED))</span><br><span class="line">                        q.append((node, RED, l+<span class="number">1</span>))</span><br><span class="line">                    <span class="comment"># 如果这点也没访问过，则找到一个新的可达点，且由于是广度优先搜索，必然是最短路</span></span><br><span class="line">                    <span class="keyword">if</span> res[node] == <span class="number">-1</span>:</span><br><span class="line">                        res[node] = l+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 0到本身距离为0，按照前面的BFS算法可能会修改0的值为某个长度（绕回来换颜色的情况），这里重新置0</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


      <blockquote class="mdui-m-t-5">
        
        <strong>本文链接：</strong><a href="http://clownw.github.io/%E5%9B%BE/">http://clownw.github.io/%E5%9B%BE/</a>
      </blockquote>
      
    </div>
    <footer class="mdui-card-actions">
      
      
        <a class="mdui-ripple article_tags-link" href="../tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag">算法总结</a>
      
    </footer>
    
  </article>
  
<script src="../https:/cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="../https:/cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>

  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="../%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/">
        下一篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>



</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2019 - 2020 ClownW<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>
    
  </div>
</footer>
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  
<script src="../js/mdui.js"></script>
<script src="../js/script.js"></script>

</body>
</html>